{"meta":{"title":"ZJC'S BLOG","subtitle":"","description":"","author":"ZJC","url":"http://yoursite.com","root":"/"},"pages":[{"title":"所有分类","date":"2020-05-21T13:31:09.843Z","updated":"2020-05-21T13:31:09.843Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-05-21T13:32:25.252Z","updated":"2020-05-21T13:32:13.092Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring5学习笔记","slug":"Spring5学习笔记","date":"2021-10-16T11:58:35.294Z","updated":"2021-10-16T12:04:28.676Z","comments":true,"path":"2021/10/16/Spring5学习笔记/","link":"","permalink":"http://yoursite.com/2021/10/16/Spring5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"1.Spring","text":"1.Spring 1.1 简介 Spring -&gt;春天，为开源软件带来春天 2002，首次退出了Spring框架的雏形：interface21框架 Spring框架以interface21框架为基础，经过重新设计，并不断丰富其内涵，于2004年3月24日发布了1.0正式版 Spring的历年：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有技术框架！ SSH：Strut2 + Spring + Hibernate（全自动持久化框架）！ SSM：SpringMVC + Spring + MyBatis（半自动持久化框架，可自定义性质更强） spring官网： https://spring.io/projects/spring-framework#overview 官方下载：https://repo.spring.io/release/org/springframework/spring/ GitHub： https://github.com/spring-projects/spring-framework Spring Web MVC： https://mvnrepository.com/artifact/org.springframework/spring-webmvc/5.2.7.RELEASE Spring Web MVC 和 Spring-JDBC的pom配置文件 12345678910111213&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; 1.2 优点 Spring是一个开源的免费框架（容器）！ Spring是一个轻量级的、非入侵式的框架！ 控制反转（IOC），面向切面编程（AOP） 支持事务处理，对框架整合的支持！（几乎市面上所有热门的框架都能整合进去）！ Spring就是一个轻量级的控制反转（IoC）和面向切面编程（AOP）的框架1.3 组成 核心容器（SpringCore）核心容器提供Spring框架的基本功能。spring以bean的方式组织和管理Java应用的各个组件及其关系，spring使用BeanFactory来产生和管理Bean，是工厂模式的实现，BeanFactory使用控制反转（IoC）模式将应用的配置和依赖性规范与实际的应用程序代码分开 应用上下文（Spring Context） Spring上下文是一个配置文件，向spring提供上下文信息，spring上下文包括企业服务 Spring面向切面编程（Spring AOP）AOP（Aspect Oriented Programming）通过配置管理特性，SpringAOP模块直接将面向方法的编程功能集成在了Spring框架中，Spring管理的任何对象都支持AOP，SpringAOP模块基于Spring的应用程序中的对象提供了事务管理服务，通过使用SpringAOP，不用依赖EJB组件，就可以将声明性事务管理集成在应用程序中 JDBC和DAO模块（Spring DAO）Dao（Data Access Object）JDBC、DAO的抽象层，提供了有意义的异常层次结构实现，可用该结构来管理异常处理，和不同数据库提供商抛出的错误信息，异常层次结构简化了错误处理，并且极大的降低了需要编写的代码数量，比如打开和关闭链接。 对象实体映射（Spring ORM）ORM（Object Relational Mapping）Spring插入了若干个ORM框架，提供了ORM对象的关系工具，其中包括Hibernate，JDO和IBatisSQL Map等，所有这些都遵从Spring的通用事务和DAO异常层次结构 Web模块（Spring Web）web上下文模块建立应用程序上下文模块之上，基于web的应用程序提供了上下文，所以spring框架支持与Struts集成，web模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作 MVC模块（SpringWebMVC）MVC（Model View Controller）MVC框架是一个全功能的构建Web应用程序的MVC实现，通过策略接口，MVC框架编程高度可配置的，MVC容纳了大量视图技术，其中包括JSP，POI等，模型由JavaBean来构成，存放于m当中，而视图是一个接口，负责实现模型，控制器表示逻辑代码，由c的事情。spring框架的功能可以用在任何J2EE服务器当中，大多数功能也适用于不受管理的环境，spring的核心要点就是支持不绑定到特定J2EE服务的可重用业务和数据的访问对象，毫无疑问这样的对象可以在不同的J2EE环境，独立应用程序和测试环境之间重用 1.4 扩展 ​ 现代化的java开发 -&gt; 基于Spring的开发！ Spring Boot一个快速开发的脚手架基于SpringBoot可以快速开发单个微服务约定大于配置！ Spring CloudSpringCloud是基于SpringBoot实现的！因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC！承上启下的作用！ 2 .IoC(控制反转)理论指导2.1 传统的调用1.UserDao 1234package dao;public interface UserDao &#123; void getUser();&#125; 2.UserDaoImpl 123456package dao;public class UserDaoImpl implements UserDao&#123; public void getUser() &#123; System.out.println(\"默认获取用户数据\"); &#125;&#125; 3.UserService 1234package Service;public interface UserService &#123; void getUser();&#125; 4.UserServiceImpl 12345678910package Service;import dao.UserDao;import dao.UserDaoImpl;public class UserServiceImpl implements UserService&#123; UserDao userDao = new UserDaoImpl(); public void getUser()&#123; userDao.getUser(); &#125; &#125; 测试： 1234567891011package holle0;import Service.UserService;import Service.UserServiceImpl;public class MyTest0 &#123; public static void main(String[] args) &#123; // 用户实际调用的是业务层，dao层他们不需要接触 UserService userService = new UserServiceImpl(); userService.getUser(); &#125;&#125; 在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！ 需要手动去new UserServiceImpl() 2.2 改进我们使用一个Set接口实现。已经发生了革命性的变化！ 12345678//在Service层的实现类(UserServiceImpl)增加一个Set()方法//利用set动态实现值的注入！//DAO层并不写死固定调用哪一个UserDao的实现类//而是通过Service层调用方法设置实现类！private UserDao userDao;public void setUserDao(UserDao userDao)&#123; this.userDao = userDao;&#125; set() 方法实际上是动态改变了 UserDao userDao 的 初始化部分（new UserDaoImpl()）((UserServiceImpl)userService).setUserDao(new UserDaoImpl()); 之前，程序是主动创建对象！控制权在程序猿手上！ 使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象！（主动权在客户手上） 本质上解决了问题，程序员不用再去管理对象的创建,系统的耦合性大大降低，可以更专注在业务的实现上 ​ 这是IoC（控制反转）的原型，反转(理解)：主动权交给了用户 注：这里的用户实际上是使用代码的人，不是不写代码的客户 使用IOC: 2.3 IOC本质控制反转 IOC（Inversion of Control）是一种程序设计思想，DI（依赖注入）是实现IOC的一种方法，也有人认为DI只是IOC的另一种说法。没有IOC的程序中，我们使用面向对象编程，对象的创建于对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 3. HelloSpringpom中引入依赖 123456&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;&lt;/dependency&gt; Hello: 1234567891011121314151617181920212223package com.zjc.pojo;public class Hello &#123; private String str; public String getStr() &#123; return str; &#125; public void setStr(String str) &#123; this.str = str; &#125; @Override public String toString() &#123; return \"Hello&#123;\" + \"str='\" + str + '\\'' + '&#125;'; &#125;&#125; beans.xml: 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--在Spring中创建对象，在Spring这些都称为bean 类型 变量名 = new 类型(); Holle holle = new Holle(); bean = 对象(holle) id = 变量名(holle) class = new的对象(new Holle();) property 相当于给对象中的属性设值,让str=\"Spring\" --&gt; //xml依赖注入arg是通过构造函数property是通过seter方法，Name属性要和seter方法后面的名字相同 &lt;bean id=\"hello\" class=\"com.kaung.pojo.Hello\"&gt; &lt;property name=\"str\" value=\"Spring\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类MyTest: 123456789101112131415161718import pojo.Hello;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MyTest &#123; public static void main(String[] args) &#123; //获取Spring的上下文对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); //我们的对象下能在都在spring·中管理了，我们要使用，直接取出来就可以了 Hello holle = (Hello) context.getBean(\"hello\"); //此方式可以避免强转 //Hello holle = context.getBean(\"hello\",Hello.class); System.out.println(holle.toString()); &#125;&#125; ClassPathXmlApplicationContext继承树（ctrl+h） ClassPathXmlApplicationContext继承接口实现类（Ctrl+Alt+u） 通俗理解：原来这套程序是：你写好菜单买好菜，客人来了自己把菜炒好招待，就相当于你请人吃饭现在这套程序是：你告诉楼下餐厅，你要哪些菜，客人来的时候，餐厅把做好的你需要的菜送上来IoC：炒菜这件事，不再由你自己来做，而是委托给了第三方__餐厅来做 此时的区别就是，如果我还需要做其他的菜，我不需要自己搞菜谱买材料再做好，而是告诉餐厅，我要什么菜，什么时候要，你做好送来 4. IoC创建对象的方式方式一：使用无参构造创建对象（默认）方式二：使用有参构造创建对象:下面介绍实体类User 123456789101112131415161718192021222324252627package com.spring.pojo;public class User &#123; public User() &#123; &#125; public User(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; String name;&#125; 下标赋值： 1234567891011 &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;pojo.User&quot;&gt; &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;zjc&quot;&#x2F;&gt; &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; 其中index指的是有参构造中参数的下标，下标从0开始 类型赋值（不建议） 123&lt;bean id=\"user\" class=\"pojo.User\"&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"zjc\"/&gt;&lt;/bean&gt; 直接通过参数名（掌握） 1234&lt;bean id=\"user\" class=\"pojo.User\"&gt; &lt;constructor-arg name=\"name\" value=\"zjc\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- 比如参数名是name，则有name=\"具体值\" --&gt; 总结：在配置文件加载的时候，容器(&lt; bean&gt;)中管理的对象就已经初始化了 5. Spring配置5.1 别名12345678&lt;bean id=\"user\" class=\"pojo.User\"&gt; &lt;constructor-arg name=\"name\" value=\"chen\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;alias name=\"user\" alias=\"userLove\"/&gt;&lt;!-- 使用时 User user2 = (User) context.getBean(\"userLove\"); --&gt; 5.2 Bean的配置123456789&lt;!--id：bean的唯一标识符，也就是相当于我们学的对象名class：bean对象所对应的会限定名：包名+类型name：也是别名，而且name可以同时取多个别名 --&gt;&lt;bean id=\"user\" class=\"pojo.User\" name=\"u1 u2,u3;u4\"&gt; &lt;property name=\"name\" value=\"chen\"/&gt;&lt;/bean&gt;&lt;!-- 使用时 User user2 = (User) context.getBean(\"u1\"); --&gt; name里面的分隔符可以是：空格 逗号 分号等 5.3 importimport一般用于团队开发使用，它可以将多个配置文件，导入合并为一个 假设，现在项目中有多个人开发，这三个人复制不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个总的！ 张三(beans.xm1) 李四(beans2.xm1) 王五(beans3.xm1) applicationContext.xml 123&lt;import resource=\"beans.xm1\"/&gt;&lt;import resource=\"beans2.xml\"/&gt;&lt;import resource=\"beans3.xm1\"/&gt; 使用的时候，直接使用总的配置就可以了注：按照在总的xml中的导入顺序来进行创建，后导入的会重写先导入的，最终实例化的对象会是后导入xml中的那个 6 依赖注入（DI） 依赖：bean对象的创建依赖于容器 注入：bean对象中的所有属性，由容器来注入 6.1 构造器注入参考4. Ioc创建对象的方式 6.2 set方式注入【重点】6.2.1创建Student类 与 Address类Address类 12345678910111213141516171819public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString() &#123; return \"Address&#123;\" + \"address='\" + address + '\\'' + '&#125;'; &#125;&#125; Student类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.kuang.pojo;import java.util.*;public class Student &#123; private String name; private Address address; private String[] books; private List&lt;String&gt; hobbies; private Map&lt;String, String&gt; card; private Set&lt;String&gt; game; private Properties infor; private String wife; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public String[] getBooks() &#123; return books; &#125; public void setBooks(String[] books) &#123; this.books = books; &#125; public List&lt;String&gt; getHobbies() &#123; return hobbies; &#125; public void setHobbies(List&lt;String&gt; hobbies) &#123; this.hobbies = hobbies; &#125; public Map&lt;String, String&gt; getCard() &#123; return card; &#125; public void setCard(Map&lt;String, String&gt; card) &#123; this.card = card; &#125; public Set&lt;String&gt; getGame() &#123; return game; &#125; public void setGame(Set&lt;String&gt; game) &#123; this.game = game; &#125; public Properties getInfor() &#123; return infor; &#125; public void setInfor(Properties infor) &#123; this.infor = infor; &#125; public String getWife() &#123; return wife; &#125; public void setWife(String wife) &#123; this.wife = wife; &#125; @Override public String toString() &#123; return \"Student&#123;\" +\"\\n\"+ \"name='\" + name + '\\'' +\"\\n\"+ \", address=\" + address.toString() +\"\\n\"+ \", books=\" + Arrays.toString(books) +\"\\n\"+ \", hobbies=\" + hobbies +\"\\n\"+ \", card=\" + card +\"\\n\"+ \", game=\" + game +\"\\n\"+ \", infor=\" + infor +\"\\n\"+ \", wife='\" + wife + '\\'' +\"\\n\"+ '&#125;'; &#125;&#125; 6.2.2 配置beans.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"address\" class=\"com.kuang.pojo.Address\"&gt; &lt;property name=\"address\" value=\"啦啦啦\"/&gt; &lt;/bean&gt; &lt;bean id=\"student\" class=\"com.kuang.pojo.Student\"&gt; &lt;!--第一种，普通值注入 --&gt; &lt;property name=\"name\" value=\"name你好\" /&gt; &lt;!--第二种，ref注入 --&gt; &lt;property name=\"address\" ref=\"address\" /&gt; &lt;!--数组注入 --&gt; &lt;property name=\"books\"&gt; &lt;array&gt; &lt;value&gt;三国&lt;/value&gt; &lt;value&gt;西游&lt;/value&gt; &lt;value&gt;水浒&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--list列表注入 --&gt; &lt;property name=\"hobbies\"&gt; &lt;list&gt; &lt;value&gt;唱&lt;/value&gt; &lt;value&gt;跳&lt;/value&gt; &lt;value&gt;rap&lt;/value&gt; &lt;value&gt;篮球&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--map键值对注入 --&gt; &lt;property name=\"card\"&gt; &lt;map&gt; &lt;entry key=\"username\" value=\"root\" /&gt; &lt;entry key=\"password\" value=\"root\" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--set(可去重)注入 --&gt; &lt;property name=\"game\"&gt; &lt;set&gt; &lt;value&gt;wangzhe&lt;/value&gt; &lt;value&gt;lol&lt;/value&gt; &lt;value&gt;galname&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--空指针null注入 --&gt; &lt;property name=\"wife\"&gt; &lt;null&gt;&lt;/null&gt; &lt;/property&gt; &lt;!--properties常量注入 --&gt; &lt;property name=\"infor\"&gt; &lt;props&gt; &lt;prop key=\"id\"&gt;20200802&lt;/prop&gt; &lt;prop key=\"name\"&gt;cbh&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 其中 array list set 均为value单闭合标签map与props比较特殊单独记忆 6.2.3 测试1234567891011import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import pojo.Student;public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\"); Student stu = (Student) context.getBean(\"student\"); System.out.println(stu.toString()); &#125; &#125; 6.3 拓展注入使用p c命名空间 User类: 123456789101112131415161718192021222324252627282930package com.kuang.pojo;public class User &#123; private String name; private int id; public User() &#123; &#125; public User(String name, int id) &#123; super(); this.name = name; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @Override public String toString() &#123; return \"User [name=\" + name + \", id=\" + id + \"]\"; &#125;&#125; 使用p和c命名空间需要导入xml约束 xmlns:p=“http://www.springframework.org/schema/p”xmlns:c=“http://www.springframework.org/schema/c” 123456789101112131415?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:c=\"http://www.springframework.org/schema/c\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--p命名空间注入/set注入，需要存在无参构造函数和对应的set方法 相当于 property--&gt; &lt;bean id=\"user\" class=\"pojo.User\" p:name=\"cxk\" p:id=\"20\" &gt; &lt;/bean&gt; &lt;!--c命名空间，通过构造器注入，需要存在相应的构造函数 相当于 construct-args --&gt; &lt;bean id=\"user2\" class=\"pojo.User\" c:name=\"cbh\" c:id=\"22\"&gt;&lt;/bean&gt;&lt;/beans&gt; 可以理解为：c-&gt;construct-args p-&gt;propertyg 官方解释为： 6 Bean作用域 只需要知道【单例模式】和【原型模式】就可以了其余的request、session、application这些只能在web开放中使用！ 6.1 单例模式默认就是单例模式 1&lt;bean id=\"user2\" class=\"pojo.User\" c:name=\"cxk\" c:age=\"19\" scope=\"singleton\"&gt;&lt;/bean&gt; 6.2原型模式每次从容器中get的时候，都产生一个新对象！ 1&lt;bean id=\"user2\" class=\"pojo.User\" c:name=\"cxk\" c:age=\"19\" scope=\"prototype\"&gt;&lt;/bean&gt; 7. Bean的自动装配自动装配是Spring满足bean依赖的一种方式Spring会在上下文自动寻找，并自动给bean装配属性在Spring中有三种装配的方式 在xml中显示配置 在java中显示配置 隐式的自动装配bean 【重要】 环境搭建：一个人有两个宠物 byType自动装配：byType会自动查找，和自己对象set方法参数的类型相同的bean 保证所有的class唯一(类为全局唯一)[如果没有set方法不会提示] byName自动装配：byName会自动查找，和自己对象set对应的值对应的id 保证所有id唯一，并且和set注入的值一致[如果没有set方法不会提示] 1234&lt;!-- 找不到id和多个相同class --&gt;&lt;bean id=\"cat1\" class=\"pojo.Cat\"/&gt;&lt;bean id=\"cat2\" class=\"pojo.Cat\"/&gt;&lt;!-- 找不到 id=cat，且有两个Cat --&gt; 7.1 测试自动装配pojo的Cat类 12345public class Cat &#123; public void shut()&#123; System.out.println(\"miao\"); &#125;&#125; pojo的Dog类 123456public class Dog &#123; public void shut()&#123; System.out.println(\"wow\"); &#125;&#125; pojo的People类 123456789101112131415161718192021222324252627282930313233343536373839package pojo;public class People &#123; private Cat cat; private Dog dog; private String name; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"People&#123;\" + \"cat=\" + cat + \", dog=\" + dog + \", name='\" + name + '\\'' + '&#125;'; &#125;&#125; xml配置 -&gt;byType 自动装配 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"cat\" class=\"pojo.Cat\"/&gt; &lt;bean id=\"dog\" class=\"pojo.Dog\"/&gt; &lt;!--byType会在容器自动查找，和自己对象属性相同的bean 例如，Dog dog; 那么就会查找pojo的Dog类，再进行自动装配 --&gt; &lt;bean id=\"people\" class=\"pojo.People\" autowire=\"byType\"&gt; &lt;property name=\"name\" value=\"cbh\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; xml配置 -&gt;byName 自动装配 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;&lt;bean id=\"cat\" class=\"pojo.Cat\"/&gt;&lt;bean id=\"dog\" class=\"pojo.Dog\"/&gt;&lt;!--byname会在容器自动查找，和自己对象set方法的set后面的值对应的id 例如:setDog()，取set后面的字符作为id，则要id = dog 才可以进行自动装配 --&gt;&lt;bean id=\"people\" class=\"pojo.People\" autowire=\"byName\"&gt; &lt;property name=\"name\" value=\"cbh\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt; byName只能匹配到小写 7.2 使用注解实现自动装配1.导入context约束：xmlns:context=”http://www.springframework.org/schema/context&quot; 2.配置注解的支持：&lt; context:annotation-config/&gt; 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 7.2.1 @Autowired默认是byType方式，如果匹配不上，就会byName在属性上个使用，也可以在set上使用我们可以不用编写set方法了，前提是自动装配的属性在Spring容器里，且要符合ByName 自动装配 1234567public class People &#123; @Autowired private Cat cat; @Autowired private Dog dog; private String name;&#125; beans.xml文件 Autowire源码 123public @interface Autowired &#123; boolean required() default true; &#125; 如果定义了Autowire的require属性为false，说明这个对象可以为null，否则不允许为空（false表示找不到装配时不抛出异常）默认为true。 7.2.2 @Autowired+@Qualifier@Autowired不能唯一装配时，需要@Autowired+@Qualifier 如果@Autowired自动装配环境比较复杂。自动装配无法通过一个注解完成的时候，可以使用@Qualifier(value = “dog”)去配合使用，指定一个唯一的id对象 12345678public class People &#123; @Autowired private Cat cat; @Autowired @Qualifier(value = \"dog\") private Dog dog; private String name;&#125; 如果xml文件中同一个对象被多个bean使用，Autowired无法按类型找到，可以用@Qualifier指定id查找 7.2.3 @Resource默认是byName方式，如果匹配不上，就会byType 1234567public class People &#123; Resource(name=\"cat\") private Cat cat; Resource(name=\"dog\") private Dog dog; private String name;&#125; Autowired是byType，@Autowired+@Qualifier = byType &amp;&amp; byName Autowired是先byteType,如果唯一則注入，否则byName查找。resource是先byname,不符合再继续byType 7.2.4 @Autowired 与 @Resource的区别 都是用来自动装配的，都可以放在属性字段上 @Autowired通过byType的方式实现，而且必须要求这个对象存在！（require默认为true）【常用】 @Resource默认通过byname的方式实现，如果找不到名字，则通过byType实现！如果两个都找不到的情况下，就报错！【常用】 执行顺序不同：@Autowired默认通过byType的方式实现。@Resource默认通过byname的方式实现 8. 使用注解开发在spring4之后，使用注解开发，必须要保证aop包的导入 使用注解需要导入contex的约束 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 8.1 bean有了&lt; context:component-scan&gt;，另一个&lt; context:annotation-config/&gt;标签可以移除掉，因为已经被包含进去了。 1234&lt;!--指定要扫描的包，这个包下面的注解才会生效 别只扫一个com.kuang.pojo包[范围如果大的话能覆盖到里面的包]--&gt; &lt;context:component-scan base-package=\"com.kuang\"/&gt; &lt;context:annotation-config/&gt; 123456//@Component 组件//等价于&lt;bean id=\"user\" classs\"pojo.User\"/&gt; @Componentpublic class User &#123; public String name =\"zjc\";&#125; @Component ：组件，放在类上，说明这个类被spring管理了，这就是bean。 8.2 属性注入@Value123456789101112@Componentpublic class User &#123; //相当于&lt;property name=\"name\" value=\"kuangshen\"/&gt; @Value(\"kuangshen\") public String name; //也可以放在set方法上面 //@Value(\"kuangshen\") public void setName(String name) &#123; this.name = name; &#125;&#125; 8.3 衍生的注解@Component有几个衍生注解，会按照web开发中，按照mvc三层架构分层。 dao （@Repository） service（@Service） controller（@Controller） 这四个注解的功能是一样的，都是代表将某个类注册到容器中 8.4 自动装配置@Autowired：默认是byType方式，如果匹配不上，就会byName @Nullable：字段标记了这个注解，说明该字段可以为空 @Resource：默认是byName方式，如果匹配不上，就会byType 8.5、作用域@Scope12345678910111213141516//原型模式prototype，单例模式singleton//scope(\"prototype\")相当于&lt;bean scope=\"prototype\"&gt;&lt;/bean&gt;@Component @Scope(\"prototype\")public class User &#123; //相当于&lt;property name=\"name\" value=\"kuangshen\"/&gt; @Value(\"kuangshen\") public String name; //也可以放在set方法上面 @Value(\"kuangshen\") public void setName(String name) &#123; this.name = name; &#125;&#125; 8.6、小结xml与注解： xml更加万能，维护简单，适用于任何场合 注解，不是自己的类使用不了，维护复杂 最佳实践： xml用来管理bean 注解只用来完成属性的注入 要开启注解支持 9 .使用java的方式配置Spring不使用Spring的xml配置，完全交给java来做！Spring的一个子项目，在spring4之后，它成为了核心功能 实体类User 1234567891011121314151617181920//这里这个注解的意思,就是说明这个类被Spring接管了,注册到了容器中 //@Component public class User &#123; private String name; public String getName() &#123; return name; &#125; //属性注入值 @value(\"QINJIANG') public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"user&#123;\" + \"name='\" + name + '\\''+ '&#125;'; &#125; &#125; 配置文件 123456789101112131415//这个也会Spring容器托管,注册到容器中,因为他本米就是一个@Component // @Configuration表这是一个配置类,就像我们之前看的beans.xml，类似于&lt;beans&gt;标签//@Configuration //@ComponentScan(\"com.Kuang.pojo\") //开启扫描//@Import(KuangConfig2.class)public class KuangConfig &#123; //注册一个bean , 就相当于我们之前写的一个bean 标签 //这个方法的名字,就相当于bean 标签中的 id 属性 -&gt;getUser //这个方法的返同值,就相当于bean 标签中的class 属性 -&gt;User //@Bean public User getUser()&#123; return new User(); //就是返回要注入到bean的对象! &#125; &#125; 使用方式： 手动注册： @Bean 1234@Bean public User getUser()&#123; return new User(); //就是返回要注入到bean的对象! &#125; 这个方法的名字,就相当于bean 标签中的 id 属性 -&gt;getUser这个方法的返同值,就相当于bean 标签中的class 属性 -&gt;User 自动注入：@ComponentScan、@Component 先开启扫描：@ComponentScan(“com.Kuang.pojo”) //开启扫描然后给相应实体类加上注解@Component 测试类 12345678public class MyTest &#123; public static void main(String[ ] args) &#123; //如果完全使用了配置类方式去做,我们就只能通过 Annotationconfig 上下文来获取容器,通过配置类的class对象加载! ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.Class); //class对象 User getUser =(User)context.getBean( \"getUser\"); //方法名getUser System.out.Println(getUser.getName()); &#125; &#125; 10. 代理模式为什么要学习代理模式，因为这就是SpringAOP的底层。 代理模式的分类： 静态代理 动态代理 10.1 静态代理 接口： 123public interface Rent &#123; public void rent();&#125; 真实角色： 1234567package pojo;public class HostMaster implements Host&#123; public void rent() &#123; System.out.println(\"房东要出租房子\"); &#125;&#125; 代理角色： 1234567891011121314151617181920212223242526272829303132public class Proxy implements Rent&#123; public HostMaster host; public Proxy() &#123; &#125; public Proxy(HostMaster host) &#123; super(); this.host = host; &#125; public void rent() &#123; seeHouse(); host.rent(); fee(); sign(); &#125; //看房 public void seeHouse() &#123; System.out.println(\"看房子\"); &#125; //收费 public void fee() &#123; System.out.println(\"收中介费\"); &#125; //合同 public void sign() &#123; System.out.println(\"签合同\"); &#125;&#125; 4.客户访问代理角色 12345678910111213public class Client &#123; public static void main(String[] args) &#123; //房东要出租房子 HostMaster host = new HostMaster(); //中介帮房东出租房子，但也收取一定费用（增加一些房东不做的操作） Proxy proxy = new Proxy(host); //看不到房东，但通过代理，还是租到了房子 proxy.rent(); &#125;&#125; 聊聊aop： 10.2 动态代理动态代理和静态代理角色一样，动态代理底层是反射机制 动态代理类是动态生成的，不是我们直接写好的！ 动态代理(两大类)：基于接口，基于类 基于接口：JDK的动态代理 基于类：cglib java字节码实现：javasisit 了解两个类 1、Proxy：代理 2、InvocationHandler：调用处理程序 1.抽象角色 1234public interface Host &#123; public void rent(); &#125; 2.真实角色 12345public class HostMaster implements Host&#123; public void rent() &#123; System.out.println(\"房东要租房子\"); &#125;&#125; 3.代理角色 1234567891011121314151617181920212223242526272829303132//我们会用这个类，自动生成代理类！public class ProxyInvocationHandler implements InvocationHandler &#123; //被代理的接口 private Rent rent; public void setRent(Rent rent) &#123; this.rent = rent; &#125; //生成得到代理类 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterfaces(),this); &#125; //处理代理实例，并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //动态代理的本质，就是使用反射机制实现！ Object result = method.invoke(rent, args); seeHose(); fee(); return result; &#125; public void seeHose()&#123; System.out.println(\"中介带着看房子！\"); &#125; public void fee()&#123; System.out.println(\"中介收取费用！\"); &#125;&#125; 4.用户类 123456789101112131415public class Client &#123; public static void main(String[] args) &#123; //真实角色 Host host = new Host(); //代理角色：现在没有 ProxyInvocationHandler pih = new ProxyInvocationHandler(); //通过调用程序处理角色来处理我们要调用的接口对象！ pih.setRent(host); Rent proxy = (Rent) pih.getProxy(); //这里的proxy就是动态生成的，我们并没有写 proxy.rent(); &#125;&#125; 在此，我们可以提炼出ProxyInvocationHandler作为工具类 123456789101112131415161718192021222324252627//用这个类自动生成代理类！public class ProxyInvocationHandler implements InvocationHandler &#123; //被代理的接口 private Object target; public void setTarget(Object target) &#123; this.target = target; &#125; //生成得到代理类 public Object getProxy()&#123; return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this); &#125; //处理代理实例，并返回结果 public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; log(method.getName()); Object result = method.invoke(target, args); return result; &#125; public void log(String msg)&#123; System.out.println(\"[Debug] 使用了一个\"+msg+\"方法\"); &#125;&#125; 动态代理的好处： 可以使真实角色的操作更加纯粹！不用去关注一些公共的业务 公共角色就交给代理角色！实现了业务的分工！ 公共业务发生扩展的时候，方便集中管理！ 一个动态代理类代理的是一个接口，一般就是对应的一类业务 一个动态代理类可以代理多个类，只要是实现了同一个接口即可！ 11、AOP11.1 什么是AOPAOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 11.2 AOP在Spring中的作用提供声明式事务；允许用户自定义切面 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志，安全，缓存，事务等等…切面（ASPECT）：横切关注点被模块化的特殊对象。即，它是一个类。通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。目标（Target）：被通知对象。代理（Proxy）：向目标对象应用通知之后创建的对象。切入点（PointCut）：切面通知执行的“地点”的定义。连接点（JointPoint）：与切入点匹配的执行点。 SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice： 即AOP在不改变原有代码的情况下，去增加新的功能。 11.3 使用Spring实现AOP【重点】使用AOP织入，需要导入一个依赖包！ 123456&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 方式一： 使用Spring的API接口【主要是SpringAPI接口实现】 在service包下，定义UserService业务接口和UserServiceImpl实现类 123456public interface UserService &#123; public void add(); public void delete(); public void update(); public void select();&#125; 1234567891011121314151617public class UserServiceImpl implements UserService &#123; public void add() &#123; System.out.println(\"增加了一个用户！\"); &#125; public void delete() &#123; System.out.println(\"删除了一个用户！\"); &#125; public void update() &#123; System.out.println(\"更新了一个用户！\"); &#125; public void select() &#123; System.out.println(\"查询了一个用户！\"); &#125;&#125; 2.在log包下，定义我们的增强类，一个Log前置增强和一个AfterLog后置增强类 123456789public class Log implements MethodBeforeAdvice &#123; //method: 要执行的目标对象的方法 //args：参数 //target：目标对象 public void before(Method method, Object[] agrs, Object target) throws Throwable &#123; System.out.println(target.getClass().getName()+\"的\"+method.getName()+\"被执行了\"); &#125;&#125; 1234567public class AfterLog implements AfterReturningAdvice &#123; //returnValue： 返回值 public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(\"执行了\"+method.getName()+\"方法，返回结果为：\"+returnValue); &#125;&#125; 3.最后去spring的文件中注册 , 并实现aop切入实现 , 注意导入约束，配置applicationContext.xml文件 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--注册bean--&gt; &lt;bean id=\"userService\" class=\"com.kuang.service.UserServiceImpl\"/&gt; &lt;bean id=\"log\" class=\"com.kuang.log.Log\"/&gt; &lt;bean id=\"afterLog\" class=\"com.kuang.log.AfterLog\"/&gt; &lt;!--方式一：使用原生Spring API接口--&gt; &lt;!--配置aop:需要导入aop的约束--&gt; &lt;aop:config&gt; &lt;!--切入点：expression：表达式，execution(要执行的位置！* * * * *)--&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/&gt; &lt;!--执行环绕增加！--&gt; &lt;aop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/&gt; &lt;aop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 4.测试 1234567891011public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //动态代理代理的是接口：注意点 UserService userService = (UserService) context.getBean(\"userService\"); userService.add();// userService.select(); &#125;&#125; 方式二： 自定义类来实现AOP【主要是切面定义】 在diy包下定义自己的DiyPointCut切入类 123456789public class DiyPointCut &#123; public void before()&#123; System.out.println(\"======方法执行前======\"); &#125; public void after()&#123; System.out.println(\"======方法执行后======\"); &#125;&#125; 2.去spring中配置文件 12345678910111213&lt;!--方式二：自定义类--&gt;&lt;bean id=\"diy\" class=\"com.kuang.diy.DiyPointCut\"/&gt;&lt;aop:config&gt; &lt;!--自定义切面，ref 要引用的类--&gt; &lt;aop:aspect ref=\"diy\"&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=\"point\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/&gt; &lt;!--通知--&gt; &lt;aop:before method=\"before\" pointcut-ref=\"point\"/&gt; &lt;aop:after method=\"after\" pointcut-ref=\"point\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 3.测试 同上 方式三： 使用注解实现！ 在diy包下定义注解实现的AnnotationPointCut增强类 123456789101112131415161718192021222324252627282930//声明式事务！@Aspect //标注这个类是一个切面public class AnnotationPointCut &#123; @Before(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void before()&#123; System.out.println(\"====方法执行前====\"); &#125; @After(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void after()&#123; System.out.println(\"====方法执行后====\"); &#125; //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点； @Around(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void around(ProceedingJoinPoint jp) throws Throwable&#123; System.out.println(\"环绕前\"); Signature signature = jp.getSignature();// 获得签名 System.out.println(\"signature:\"+signature); Object proceed = jp.proceed(); //执行方法 System.out.println(\"环绕后\"); System.out.println(proceed); &#125;&#125; 2.在Spring配置文件中，注册bean，并增加支持注解的配置。 1234&lt;!--方式三：使用注解--&gt;&lt;bean id=\"annotationPointCut\" class=\"com.kuang.diy.AnnotationPointCut\"/&gt;&lt;!--开启注解支持！ JDK(默认是 proxy-target-class=\"false\") cglib（proxy-target-class=\"true\"）--&gt;&lt;aop:aspectj-autoproxy/&gt; 12 .整合mybatismybatis-spring官网：https://mybatis.org/spring/zh/mybatis的配置流程： 编写实体类 编写核心配置文件 编写接口 编写Mapper.xmi 测试 12.1 mybatis-spring-方式一 编写数据源配置 sqISessionFactory sqISessionTemplate（相当于sqISession） 需要给接口加实现类【new】 将自己写的实现类，注入到Spring中 测试！ 先导入jar包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;!--Spring-webMVC--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--AOP--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;!--Spirng-jdbc--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis-spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--在build中配置resources，来防止资源导出失败的问题--&gt; &lt;!-- Maven解决静态资源过滤问题 --&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 实体类 12345678import lombok.Data;@Datapublic class User &#123; private int id; private String name; private String pwd;&#125; 接口UserMapper 123456package mapper;import java.util.List;import pojo.User;public interface UserMapper &#123; public List&lt;User&gt; getUser();&#125; UserMapperImpl 1234567891011121314151617181920package mapper;import java.util.List;import org.mybatis.spring.SqlSessionTemplate;import pojo.User;public class UserMapperImpl implements UserMapper&#123; //我们的所有操作，在原来都使用sqlSession来执行，现在都使用SqlSessionTemplate； private SqlSessionTemplate sqlSessionTemplate; //此处set方法是为了在Spring配置文件中注入属性时使用 public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) &#123; this.sqlSessionTemplate = sqlSessionTemplate; &#125; public List&lt;User&gt; getUser() &#123; UserMapper mapper = sqlSessionTemplate.getMapper(UserMapper.class); return mapper.getUser(); &#125;&#125; UserMapper.xml 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;!-- 绑定接口 --&gt;&lt;mapper namespace=\"com.kuang.mapper.UserMapper\"&gt; &lt;select id=\"getUser\" resultType=\"com.kuang.pojo.User\"&gt; select * from mybatis.mybatis &lt;/select&gt;&lt;/mapper&gt; resource目录下的 mybatis-config.xml、spring-dao.xml、applicationContext.xml mybatis-config.xml（可以完全省略，在spring-dao中的sqlSessionFactory位置设置） 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!--开启日志--&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;/settings&gt; &lt;!--可以给实体类起别名 --&gt; &lt;typeAliases&gt; &lt;package name=\"pojo\" /&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; spring-dao.xml（代替之前的MybatisUtils工具类） 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--DataSource:使用Spring的数帮源替换Mybatis的配置 其他数据源：c3p0、dbcp、druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --&gt; &lt;!--data source --&gt; &lt;bean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;userSSL=false&amp;amp;serverTimezone=GMT%2B8\"/&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"123456\" /&gt; &lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"datasource\" /&gt; &lt;!--绑定 mybatis 配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/kuang/mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!-- sqlSessionTemplate 就是之前使用的：sqlsession --&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;!-- 只能使用构造器注入sqlSessionFactory 原因：它没有set方法--&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt; &lt;bean id=\"userMapper\" class=\"com.kuang.mapper.UserMapperImpl\"&gt; &lt;property name=\"sqlSessionTemplate\" ref=\"sqlSession\"/&gt; &lt;/bean&gt;&lt;/beans&gt; applicationContext.xml(导入spring-dao.xml) 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!-- 导入spring-dao.xml --&gt; &lt;import resource=\"spring-dao.xml\"/&gt; &lt;bean id=\"userMapper\" class=\"mapper.UserMapperImpl\"&gt; &lt;property name=\"sqlSessionTemplate\" ref=\"sqlSession\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试 123456789101112131415161718import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import mapper.UserMapper;import pojo.User;public class MyTest &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //注意此处第二个参数只能填写UserMapperImpl.class，而不能写UserMapper.class //UserMapperImpl userMapper = context.getBean(\"userMapper\", UserMapperImpl.class); UserMapper userMapper = (UserMapper) context.getBean(\"userMapper\"); for (User user : userMapper.getUser()) &#123; System.out.println(user); &#125; &#125;&#125; 12.2 mybatis-spring-方式二 UserServiceImpl2 1234567891011121314package mapper;import pojo.User;import org.apache.ibatis.session.SqlSession;import org.mybatis.spring.support.SqlSessionDaoSupport;import java.util.List;//继承SqlSessionDaoSupport 类public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper &#123; public List&lt;User&gt; getUser() &#123; SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUser(); //或者一句话：return getSqlSession().getMapper(UserMapper.class).getUser(); &#125;&#125; spring-dao.xml 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--DataSource:使用Spring的数帮源替换Mybatis的配置 其他数据源：c3p0、dbcp、druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --&gt; &lt;!--data source --&gt; &lt;bean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;userSSL=false&amp;amp;serverTimezone=GMT%2B8\"/&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"123456\" /&gt; &lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"datasource\" /&gt; &lt;!--绑定 mybatis 配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/kuang/mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!-- sqlSessionTemplate 就是之前使用的：sqlsession --&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;!-- 只能使用构造器注入sqlSessionFactory 原因：它没有set方法--&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/&gt; &lt;/bean&gt; &lt;!-- 方法二：SqlSessionTemplate 可以不写了--&gt;&lt;/beans&gt; applicationContext.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;import resource=\"spring-dao.xml\" /&gt; &lt;!-- 方法二 --&gt; &lt;bean id=\"userMapper2\" class=\"mapper.UserMapperImpl2\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试 123456789public class MyTest6 &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = (UserMapper) context.getBean(\"userMapper2\"); for (User user : userMapper.getUser()) &#123; System.out.println(user); &#125; &#125;&#125; 13. 声明式事务 把一组业务当成一个业务来做；要么都成功，要么都失败！ 事务在项目开发中，十分的重要，涉及到数据的一致性问题 确保完整性和一致性 事务的ACID原则：1，原子性（atomic），事务由一个或多个行为捆绑在一起构成，好像是一个单独的工作单元。原子性保证事务内的操作要么都发生，要么都不发生。假如所有的操作都成功了，那么事务是成功的。加入任何一个操作失败，那么事务会进行回滚。 2，一致性（consistent），一旦一个事务结束了，不管成功还是失败，系统所处的状态和它的业务规则是一致的。也就是说，数据应当不会被破坏。 3，隔离性（isolation），事务应当允许多名用户操作同一个数据，一个用户的操作不会和其他用户的操作相混淆。因此，事务必须是隔离的，防止并行读写同一个数据的情况发生。注意，隔离通常意味着要锁定数据库的表或行。 4，持久性（durable），一旦事务完成，事务的结果应当持久化。这样不管什么样的系统崩溃，它们都能幸免于难。 声明式事务 先导入jar包，并没有新增的依赖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; &lt;!--在build中配置resources，来防止资源导出失败的问题--&gt;&lt;!-- Maven解决静态资源过滤问题 --&gt;&lt;build&gt;&lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt;&lt;/resources&gt;&lt;/build&gt; pojo实体类User 123456789101112import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class User &#123; private int id; private String name; private String pwd;&#125; 接口UserMapper 1234567891011import java.util.List;import org.apache.ibatis.annotations.Param;import pojo.User;public interface UserMapper &#123; public List&lt;User&gt; getUser(); public int insertUser(User user); public int delUser(@Param(\"id\") int id); &#125; UserMapperImpl 123456789101112131415161718192021222324import pojo.User;import org.apache.ibatis.session.SqlSession;import org.mybatis.spring.support.SqlSessionDaoSupport;import java.util.List;public class UserMapperImpl extends SqlSessionDaoSupport implements UserMapper &#123; public List&lt;User&gt; getUser() &#123; User user = new User(5,\"你好\",\"ok\"); insertUser(user); delUser(5); SqlSession sqlSession = getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); return mapper.getUser(); //或者return getSqlSession().getMapper(UserMapper.class).getUser(); &#125; //插入 public int insertUser(User user) &#123; return getSqlSession().getMapper(UserMapper.class).insertUser(user); &#125; //删除 public int delUser(int id) &#123; return getSqlSession().getMapper(UserMapper.class).delUser(id); &#125;&#125; UserMapper.xml 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- 绑定接口 --&gt;&lt;mapper namespace=\"com.kuang.mapper.UserMapper\"&gt; &lt;select id=\"getUser\" resultType=\"user\"&gt; select * from mybatis.user &lt;/select&gt; &lt;insert id=\"insertUser\" parameterType=\"user\" &gt; insert into mybatis.user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;) &lt;/insert&gt; &lt;delete id=\"delUser\" parameterType=\"_int\"&gt; delete from mybatis.user where id = #&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; mybatis-config.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!-- configuration --&gt;&lt;configuration&gt; &lt;!--开启日志--&gt; &lt;settings&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;/settings&gt; &lt;!--可以给实体类起别名--&gt; &lt;typeAliases&gt; &lt;package name=\"pojo\" /&gt; &lt;/typeAliases&gt;&lt;/configuration&gt; spring-dao.xml（已导入约束） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--DataSource:使用Spring的数帮源替换Mybatis的配置 其他数据源：c3p0、dbcp、druid 这使用Spring提供的JDBC: org.springframework.jdbc.datasource --&gt; &lt;!--data source --&gt; &lt;bean id=\"datasource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql:///mybatis?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;userSSL=false&amp;amp;serverTimezone=GMT%2B8\"/&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"123456\" /&gt; &lt;/bean&gt; &lt;!--sqlSessionFactory--&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"datasource\" /&gt; &lt;!--绑定 mybatis 配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/kuang/mapper/*.xml\"/&gt; &lt;/bean&gt; &lt;!--声明式事务--&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;constructor-arg ref=\"datasource\" /&gt; &lt;/bean&gt; &lt;!--结合aop实现事务织入--&gt; &lt;!--配置事务的通知类--&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;!--给哪些方法配置事务--&gt; &lt;!--新东西：配置事务的传播特性 propagation--&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"add\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"delete\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"update\" propagation=\"REQUIRED\"/&gt; &lt;tx:method name=\"query\" read-only=\"true\"/&gt; &lt;!-- *号包含上面4个方法： &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt; --&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置事务切入--&gt; &lt;aop:config&gt; &lt;aop:pointcut id=\"txpointcut\" expression=\"execution(* com.kuang.mapper.*.*(..))\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txpointcut\"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; Spring中七种Propagation类的事务属性详解： REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择也是spring的默认选择。 SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。 MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。 REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 NESTED：支持当前事务，如果当前事务存在，则执行一个嵌套事务，如果当前没有事务，就新建一个事务。 applicationContext.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;import resource=\"spring-dao.xml\" /&gt; &lt;bean id=\"userMapper\" class=\"mapper.UserMapperImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 1234567891011121314151617import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import mapper.UserMapper;import pojo.User;public class MyTest&#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); UserMapper userMapper = (UserMapper) context.getBean(\"userMapper\"); for (User user : userMapper.getUser()) &#123; System.out.println(user); &#125; &#125;&#125; 注意：UserMapperImpl中getUser()方法先插入一个user在删除一个user。只有在同一次使用Sqlsession时事务才起作用。 上述文件主要看spring-dao最后那部分即可","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"SSM框架","slug":"SSM框架","permalink":"http://yoursite.com/tags/SSM%E6%A1%86%E6%9E%B6/"}]},{"title":"Win10环境+ CUDA9.0 +CUDNN7.0+TensorFlow1.7_1.6_1.5配置（亲测有效）","slug":"Win10环境+ CUDA9.0 +CUDNN7.0+TensorFlow1.7_1.6_1.5配置（亲测有效）","date":"2020-05-24T15:01:41.576Z","updated":"2020-05-24T15:07:35.187Z","comments":true,"path":"2020/05/24/Win10环境+ CUDA9.0 +CUDNN7.0+TensorFlow1.7_1.6_1.5配置（亲测有效）/","link":"","permalink":"http://yoursite.com/2020/05/24/Win10%E7%8E%AF%E5%A2%83+%20CUDA9.0%20+CUDNN7.0+TensorFlow1.7_1.6_1.5%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%B2%E6%B5%8B%E6%9C%89%E6%95%88%EF%BC%89/","excerpt":"前言：很多小伙伴在选择CUDA版本和cudnn版本上有疑问，这里简短的说一下，希望能帮到各位小伙伴，我在网上看到有人说，要根据自己的显卡来选择CUDA，其实是错误的，你可以下载自己所需要的CUDA版本,这只是个驱动而已。CUDA的版本和cundd的版本要对应，不然可能会有不兼容报错。CUDA是显卡驱动程序，cundd是用来加速深度学习训练的库，在训练网络时，使用GPU加速，会调CUDA驱动和cudnn库，安装时两者要联系起来，本文的第二步，就是做这个事。","text":"前言：很多小伙伴在选择CUDA版本和cudnn版本上有疑问，这里简短的说一下，希望能帮到各位小伙伴，我在网上看到有人说，要根据自己的显卡来选择CUDA，其实是错误的，你可以下载自己所需要的CUDA版本,这只是个驱动而已。CUDA的版本和cundd的版本要对应，不然可能会有不兼容报错。CUDA是显卡驱动程序，cundd是用来加速深度学习训练的库，在训练网络时，使用GPU加速，会调CUDA驱动和cudnn库，安装时两者要联系起来，本文的第二步，就是做这个事。 系统环境：windows10 64位 显卡：GTX1060 CUDA版本:cuda_9.0.176_win10（配套的cudnn一定要是7版本） 下载地址：https://developer.nvidia.com/cuda-90-download-archive CUDNN版本:cudnn-9.0-windows10-x64-v7（7版本的） 下载地址：https://developer.nvidia.com/cudnn TensorFlow-gpu版本：TensorFlow1.7（1.6和1.5也支持） 1.下载CUDA, https://developer.nvidia.com/cuda-90-download-archive 按照自己机器的信息选择，下图是我自己机器信息：下载完之后直接点击运行，会自行安装，安装时会让你选择一个文件夹作为抽取文件临时存放，记住这不是安装文件夹，安装文件夹系统会自动安装到C盘，具体我后面会提到，临时文件夹安装完后会自动删除。 2.下载cudnn,下载地址：https://developer.nvidia.com/cudnn，进去之后,找到对应的版本，点击Download，他会要你注册登录，然后填个问卷，才可以下载，这一步自行按照网站提示做就可以了。提交完问卷后，就可以点击下载了。以下是版本选择界面： 勾选这个，然后选择要下载的版本，我选的是图中划线那个（应该选择7.0版本，7.1可能有些不兼容）下载完，解压cudnn,会出现四个文件，如下：接下来，我们要将CUDA和CUDNN链接起来，这样CUDA才能调用CUDNN.这里有两种方法将CUDA和CUDNN链接起来 第一种： 在环境变量下面，把解压后文件的bin目录加到系统环境变量中，放在path下面，如图： 重启一下电脑，让环境变量生效，完成。 第二种： 就是把cudnn中的库加入到CUDA中，因为CUDA系统会自动安装到c盘的Program Files文件中，选择该文件夹下的NVIDIA GPUComputing Toolkit文件，一直到这个文件夹下有如下文件，我标出的这三个，和cudnn中的前三个文件是对应的如下图：接下来要做的就是，把cudnn三个文件夹中的文件，复制到CUDA相应文件夹的下面（仔细看一下就会发现他们的目录结构是一样的），完成。 3.安装TensorFlow 安装：在命令窗口中输入pip install tensorflow-gpu， 如果要安装（更新）最新的版本，可输入： pip install –upgrade tensorFlow-gpu 等待安装完成即可 4.现在CUDA,cudnn,TensorFlow都已经安装好了，可以尽情的去写TensorFlow代码啦！ （注：新手第一次使用TensorFlow-GPU版时，训练网络时应该在tf.session处做一点修改，如下： 将with tf.Session() as sess: 改为： config = tf.ConfigProto()config.gpu_options.allow_growth = True with tf.Session(config=config) as sess: 否则可能会报错：原因是当TensorFlow要大量使用GPU时，不会自动给其分配资源，需要手动调整。 ）","categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://yoursite.com/categories/TensorFlow/"}],"tags":[{"name":"CUDA","slug":"CUDA","permalink":"http://yoursite.com/tags/CUDA/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://yoursite.com/tags/TensorFlow/"}]},{"title":"使用清华镜像快速下载TensorFlow各版本及已安装版本查看","slug":"使用清华镜像快速下载TensorFlow各版本及已安装版本查看","date":"2020-05-24T14:59:05.471Z","updated":"2020-05-24T15:00:01.211Z","comments":true,"path":"2020/05/24/使用清华镜像快速下载TensorFlow各版本及已安装版本查看/","link":"","permalink":"http://yoursite.com/2020/05/24/%E4%BD%BF%E7%94%A8%E6%B8%85%E5%8D%8E%E9%95%9C%E5%83%8F%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BDTensorFlow%E5%90%84%E7%89%88%E6%9C%AC%E5%8F%8A%E5%B7%B2%E5%AE%89%E8%A3%85%E7%89%88%E6%9C%AC%E6%9F%A5%E7%9C%8B/","excerpt":"使用清华镜像快速下载TensorFlow各版本：","text":"使用清华镜像快速下载TensorFlow各版本： 1pip install tensorflow-gpu==1.12.0 -i https://pypi.tuna.tsinghua.edu.cn/simple #可改成任意版本","categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://yoursite.com/categories/TensorFlow/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://yoursite.com/tags/TensorFlow/"},{"name":"清华镜像","slug":"清华镜像","permalink":"http://yoursite.com/tags/%E6%B8%85%E5%8D%8E%E9%95%9C%E5%83%8F/"}]},{"title":"用python不到3秒找出1亿以内的质数","slug":"用python不到3秒找出1亿以内的质数","date":"2020-05-24T14:56:24.678Z","updated":"2020-05-24T15:09:23.031Z","comments":true,"path":"2020/05/24/用python不到3秒找出1亿以内的质数/","link":"","permalink":"http://yoursite.com/2020/05/24/%E7%94%A8python%E4%B8%8D%E5%88%B03%E7%A7%92%E6%89%BE%E5%87%BA1%E4%BA%BF%E4%BB%A5%E5%86%85%E7%9A%84%E8%B4%A8%E6%95%B0/","excerpt":"下面是用python不到3秒找出1亿以内的质数","text":"下面是用python不到3秒找出1亿以内的质数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# -*- coding: utf-8 -*-import sys, timeimport numpy as npdef find_prime(upper): \"\"\"找出小于upper的所有质数\"\"\" prime_list = list() mid = int(np.sqrt(upper)) nums = np.arange(upper) nums[1] = 0 while True: primes = nums[nums&gt;0] if primes.any(): p = primes[0] prime_list.append(p) nums[p::p] = 0 if p &gt; mid: break else: break prime_list.extend(nums[nums&gt;0].tolist()) return prime_listdef fast_find_prime(upper, base=100000, block=20000000): \"\"\"快速找出小于upper的所有质数\"\"\" if upper &lt;= base: return find_prime(upper) mid = int(np.sqrt(upper)) prime_list = find_prime(base) prime_array = np.array(prime_list) prime_array = prime_array[prime_array&lt;=mid] start = base while start &lt; upper: end = start + block if end &gt; upper: end = upper print((start, end)) prime_list.extend(process_func(start, np.copy(prime_array), (start, end))) start += block return prime_listdef process_func(id, primes, task_range): \"\"\"执行分块任务的函数 primes - 用以剔除非质数的质数表 task_range - 分块任务的数值范围 \"\"\" nums = np.arange(task_range[0], task_range[1]) for p in primes: k = (p-task_range[0]%p)%p nums[k::p] = 0 return nums[nums&gt;0].tolist()upper = 100000000t0 = time.time()prime_list = fast_find_prime(upper)t1 = time.time()print('查找%d以内的质数耗时%0.3f秒，共找到%d个质数'%(upper, t1-t0, len(prime_list)))","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"数字统计","slug":"数字统计","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E7%BB%9F%E8%AE%A1/"}]},{"title":"nodejs安装与配置","slug":"nodejs安装与配置","date":"2020-05-22T14:01:03.026Z","updated":"2020-05-22T14:08:42.872Z","comments":true,"path":"2020/05/22/nodejs安装与配置/","link":"","permalink":"http://yoursite.com/2020/05/22/nodejs%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"1.下载对应的nodejs安装包","text":"1.下载对应的nodejs安装包 https://nodejs.org/en/download/ 2.运行安装包，选择相关的路径，主要注意点如下选择add to path,因为这样会自动给你配置对应的环境变量，其余的都是直接下一步下一步然后install 3.检验是否安装成功，执行两个命令node -v 和npm -v(这个主要高版本的nodejs会在安装的过程中自动帮你安装的，主要的作用是对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西) 分别查看版本信息","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"http://yoursite.com/tags/Nodejs/"}]},{"title":"如何发布文章到自己搭建的hexo博客上！","slug":"如何发布文章到自己搭建的hexo博客上！","date":"2020-05-21T13:35:18.076Z","updated":"2020-05-22T05:50:21.489Z","comments":true,"path":"2020/05/21/如何发布文章到自己搭建的hexo博客上！/","link":"","permalink":"http://yoursite.com/2020/05/21/%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0%E5%88%B0%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E7%9A%84hexo%E5%8D%9A%E5%AE%A2%E4%B8%8A%EF%BC%81/","excerpt":"下面是发布博客的两种方法","text":"下面是发布博客的两种方法 第一种方法1.选择一个markdown编辑器，我觉得csdn自带的md编辑器就挺好用的，所以你可以注册一个csdn帐号，微信扫一扫就ok；2.注册成功后登录进去，由于默认的是HTML编辑器，所以我们需要先修改下默认设置，首先找到右上角头像的位置，选择账号设置，然后如图选择我的博客next 往下翻找到 默认编辑器类型：选择MarkDown编辑器 保存就ok了；3.点击写博客，先了解下markdown编辑器基本的用法，然后就可以写博客了，写好之后导出到本地如图，点击后选择MarkDown，会下载一个 .md 文件；然后找到这个md文件，把它复制到你hexo博客文件夹 中 source 下的 _posts 中，默认只有一个 hello-world.md； 复制完之后然后使用文本编辑器打开它，在第一行加上title，内容自定，如 1title: this is my first blog 5.接着在你博客站点文件夹下右键空白处，选择Git Bash Here，输入 hexo g (完整命令为hexo generate)，用于生成静态文件6 然后 输入 hexo s(完整命令为hexo server)，用于启动服务器，主要用来本地预览；完成后 打开浏览器输入 localhost:4000，会发现多了你刚写的那篇博客7 最后输入hexo d(hexo deploy)，用于将本地文件发布到github等git仓库上；8 好了，大功告成！ 第二种方法① 新建一个空文章，输入以下命令，会在项目 \\Hexo\\source_posts 中生成 文章标题.md 文件，文章标题根据需要命名 1$ hexo n \"文章标题\" 也可以直接在 \\Hexo\\source_posts 目录下右键鼠标新建文本文档，改后缀为 .md 即可，这种方法比较方便 ② 用编辑器编写文章 md 全称 Markdown， Markdown 是 2004 年由 John Gruberis 设计和开发的纯文本格式的语法，非常的简单实用，常用的标记符号屈指可数，几分钟即可学会， .md 文件可以使用支持 Markdown 语法的编辑器编辑，然后保存文件到 \\Hexo\\source_posts 文件夹下即可 推荐 Windows 上使用 MarkdownPad2 或者小书匠 编辑器，macOS 上使用 Mou 编辑器，Linux 上使用 Remarkable编辑器，Web 端上使用CSDN ，其他编辑器推荐可以参考我的另一篇文章：《最新主流 Markdown 编辑器推荐》 文章标题，标签，分类，封面图片，摘要等，可以在 Front-matter 里面配置（Front-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，官方文档：https://hexo.io/zh-cn/docs/front-matter ），举个例子： 1234567891011121314151617181920---layout: 页面布局（配合主题文档使用）title: 文章名称date: 文章日期comments: 文章是否开启评论photos: 文章封面图（仅部分主题支持）tags: - 文章标签一 - 文章标签二categories: 文章分类description: 文章描述，即要在首页显示的摘要（仅部分主题支持）---这里是摘要&lt;!-- more --&gt;这里是正文注意：description 和 &lt;!-- more --&gt; 方式显示摘要二选一即可，部分主题不支持description，每个配置英文冒号后面要空一格，不同主题配置有所差异，具体要参考主题文档 当我们用编辑器写好文章后，可以使用以下命令将其推送到服务器上 12$ hexo g $ hexo d 或者将两个命令合二为一输入以下命令： 1$ hexo d -g 现在访问你的博客就可以看见写好的文章啦！","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"发布博客","slug":"发布博客","permalink":"http://yoursite.com/tags/%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/"}]},{"title":"使用 Github 和 Hexo 搭建自己的独立博客","slug":"使用 Github 和 Hexo 搭建自己的独立博客","date":"2020-05-20T10:01:21.916Z","updated":"2021-10-16T13:26:26.434Z","comments":true,"path":"2020/05/20/使用 Github 和 Hexo 搭建自己的独立博客/","link":"","permalink":"http://yoursite.com/2020/05/20/%E4%BD%BF%E7%94%A8%20Github%20%E5%92%8C%20Hexo%20%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/","excerpt":"我的博客地址：https://supremezjc.github.io","text":"我的博客地址：https://supremezjc.github.io @TOC ● 入门Github PagesGithub Pages可以被认为是用户编写的、托管在github上的静态网页。使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。此外还可以绑定自己的域名。 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 ● 安装 Node.js点击此处访问官网，按需下载相应版本，默认安装可以了。如果不懂可以看我的另一篇文章nodejs的安装和配置 ● 安装 Git点击此处访问官网，按需下载相应版本，默认安装即可 • 检验Git是否安装成功同时按下 Win 键和 R 键打开运行窗口,输入 cmd ，然后输入以下命令，有相应版本信息显示则安装成功，若不正确可以卸载软件重新安装，此外若安装成功，在桌面右键鼠标，可以看到菜单里多了 Git GUI Here 和 Git Bash Here两个选项，第一个是图形界面的Git操作，另一个是命令行 123$ git --version $ node -v $ npm -v ● 安装Hexo选择一个磁盘，新建一个文件夹，自己重命名文件夹（如：我的文件夹为：Ｅ\\TRHX_Blog），博客相关文件将储存在此文件夹下，在该文件夹下右键鼠标，点击 Git Bash Here，输入以下 npm 命令即可安装，第一个命令表示安装 hexo，第二个命令表示安装 hexo 部署到 git page 的 deployer，如图所示即为安装成功 12$ npm install hexo-cli -g $ npm install hexo-deployer-git --save • Hexo 初始化配置在刚才新建的文件夹里面再次新建一个 Hexo 文件夹（如：我的文件夹为：E\\TRHX_Blog\\Hexo）,进入该 Hexo 文件夹右键鼠标，点击 Git Bash Here，输入以下命令，如图所示则安装成功 1$ hexo init Hexo 安装完成后，将会在指定文件夹中新建所需要的文件，Hexo 文件夹下的目录如下： ● 本地查看效果执行以下命令，执行完即可登录 http://localhost:4000/ 查看效果 12$ hexo generate $ hexo server 显示以下信息说明操作成功： 1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. ● 将博客部署到 Github Pages 上到目前为止，我们的本地博客就成功搭建了，但是现在我们只能通过本地连接查看博客，我们要做的是让其他人也能够访问我们的博客，这就需要我们将博客部署到Github Pages上 • 注册 Github 账户点击此处访问 Github 官网，点击 Sign Up 注册账户 • 创建项目代码库点击 New repository 开始创建，步骤及注意事项见下图： • 配置 SSH 密钥只有配置好 SSH 密钥后，我们才可以通过 git 操作实现本地代码库与 Github 代码库同步，在你第一次新建的文件夹里面（如：我的文件夹为：Ｅ\\TRHX_Blog） Git Bash Here 输入以下命令： 12$ ssh-keygen -t rsa -C \"your email@example.com\" //引号里面填写你的邮箱地址，比如我的是1248164682.qq.com 之后会出现： 123Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): //到这里可以直接回车将密钥按默认文件进行存储 然后会出现： 123Enter passphrase (empty for no passphrase): //这里是要你输入密码，其实不需要输什么密码，直接回车就行 Enter same passphrase again: 接下来屏幕会显示： 123456Your identification has been saved in /c/Users/you/.ssh/id_rsa. Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub. The key fingerprint is: 这里是各种字母数字组成的字符串，结尾是你的邮箱 The key's randomart image is: 这里也是各种字母数字符号组成的字符串 运行以下命令，将公钥的内容复制到系统粘贴板上 1$ clip &lt; ~/.ssh/id_rsa.pub • 在 GitHub 账户中添加你的公钥① 登陆 GitHub，进入 Settings：② 点击 SSH and GPG Keys：③ 选择 New SSH key：④ 粘贴密钥： • 测试输入以下命令：注意：git@github.com不要做任何更改！ 1$ ssh -T git@github.com 之后会显示：输入 yes 后会显示： • 配置 Git 个人信息Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的，名字可以不是 GitHub 的昵称，但为了方便记忆，建议与 GitHub 一致 12$ git config --global user.name \"此处填你的用户名\" $ git config --global user.email \"此处填你的邮箱\" 到此为止 SSH Key 配置成功，本机已成功连接到 Github ● 将本地的 Hexo 文件更新到 Github 的库中① 登录 Github 打开自己的项目 your name.github.io② 鼠标移到 Clone or download 按钮，选择 Use SSH③ 一键复制地址④ 打开你创建的 Hexo 文件夹（如：E:\\TRHX_Blog\\Hexo），右键用记事本（Notepad++或者VS code等都可以）打开该文件夹下的 _config.yml 文件⑤ 按下图修改 _config.yml 文件并保存⑥ 在 Hexo 文件夹下分别执行以下命令 12$ hexo g $ hexo d 或者直接执行 1$ hexo g -d 执行完之后会让你输入你的 Github 的账号和密码，如果此时报以下错误，说明你的 deployer 没有安装成功 1ERROR Deployer not found: git 需要执行以下命令再安装一次： 1npm install hexo-deployer-git --save 再执行 hexo g -d，你的博客就会部署到 Github 上了⑦ 访问博客 你的博客地址：https://你的用户名.github.io，比如我的是：https://supemezjc.github.io ,现在每个人都可以通过此链接访问你的博客了。 在博客中发表文章和申请域名请看我的其他文章。这里非常感谢这位博主：https://blog.csdn.net/qq_36759224/article/details/82121420他写的非常详细。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"26 种不同的编程语言的 “Hello World” 程序","slug":"26 种不同的编程语言的 “Hello World” 程序","date":"2020-05-18T08:16:47.150Z","updated":"2020-05-24T14:58:04.250Z","comments":true,"path":"2020/05/18/26 种不同的编程语言的 “Hello World” 程序/","link":"","permalink":"http://yoursite.com/2020/05/18/26%20%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%20%E2%80%9CHello%20World%E2%80%9D%20%E7%A8%8B%E5%BA%8F/","excerpt":"下面是用26中计算机语言编写的”Hello World”","text":"下面是用26中计算机语言编写的”Hello World” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293941. C#include int main()&#123; printf(\"Hello, World\"); return(0);&#125;2. C++#include int main()&#123; std::cout &lt;&lt; \"Hello World\"; return 0;&#125;3. C#using System;class Program&#123; public static void Main(string[] args) &#123; Console.WriteLine(\"Hello, World\"); &#125;&#125;4. Bashecho \"Hello, World\"5. BasicPRINT \"Hello, World\"6. HTML Hello, World7. Javapublic class Main &#123; public static void main(String[] args) &#123; System.out.println(\"Hello, World!\"); &#125;&#125;8. Clipper? \"Hello, World\"9. Delphiprogram HelloWorld;begin Writeln('Hello, World');end.10. CoffeeScriptconsole.log 'Hello, World'11. MatLabdisp('Hello, World')12. Juliaprintln(\"Hello, World\")13. JavaScriptdocument.write('Hello, World');14. Logoprint [Hello, World]15. jQuery$(\"body\").append(\"Hello, World\");16. Perl 5print \"Hello, World\";17. Pascalprogram HelloWorld;begin WriteLn('Hello, World');end.18. Objective-C#import #import int main(void)&#123; NSLog(@\"Hello, World\"); return 0;&#125;19. Visual Basic .NETModule Module1 Sub Main() Console.WriteLine(\"Hello, World\") End SubEnd Module20. Rcat('Hello, World')21. VBScriptMsgBox \"Hello, World\"22. XSLT Hello, World23. Processingvoid setup()&#123; println(\"Hello, World\");&#125;24. Rubyputs \"Hello, World\"25. Swiftprint(\"Hello, World\")26. Pythonprint (\"Hello, World\")","categories":[{"name":"随便玩玩","slug":"随便玩玩","permalink":"http://yoursite.com/categories/%E9%9A%8F%E4%BE%BF%E7%8E%A9%E7%8E%A9/"}],"tags":[{"name":"Hello World","slug":"Hello-World","permalink":"http://yoursite.com/tags/Hello-World/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-05-16T05:47:20.881Z","updated":"2020-05-24T15:05:14.315Z","comments":true,"path":"2020/05/16/hello-world/","link":"","permalink":"http://yoursite.com/2020/05/16/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hello World","slug":"Hello-World","permalink":"http://yoursite.com/categories/Hello-World/"}],"tags":[{"name":"随便玩玩","slug":"随便玩玩","permalink":"http://yoursite.com/tags/%E9%9A%8F%E4%BE%BF%E7%8E%A9%E7%8E%A9/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://yoursite.com/categories/TensorFlow/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"},{"name":"随便玩玩","slug":"随便玩玩","permalink":"http://yoursite.com/categories/%E9%9A%8F%E4%BE%BF%E7%8E%A9%E7%8E%A9/"},{"name":"Hello World","slug":"Hello-World","permalink":"http://yoursite.com/categories/Hello-World/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"SSM框架","slug":"SSM框架","permalink":"http://yoursite.com/tags/SSM%E6%A1%86%E6%9E%B6/"},{"name":"CUDA","slug":"CUDA","permalink":"http://yoursite.com/tags/CUDA/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://yoursite.com/tags/TensorFlow/"},{"name":"清华镜像","slug":"清华镜像","permalink":"http://yoursite.com/tags/%E6%B8%85%E5%8D%8E%E9%95%9C%E5%83%8F/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"数字统计","slug":"数字统计","permalink":"http://yoursite.com/tags/%E6%95%B0%E5%AD%97%E7%BB%9F%E8%AE%A1/"},{"name":"Nodejs","slug":"Nodejs","permalink":"http://yoursite.com/tags/Nodejs/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"发布博客","slug":"发布博客","permalink":"http://yoursite.com/tags/%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/"},{"name":"Hello World","slug":"Hello-World","permalink":"http://yoursite.com/tags/Hello-World/"},{"name":"随便玩玩","slug":"随便玩玩","permalink":"http://yoursite.com/tags/%E9%9A%8F%E4%BE%BF%E7%8E%A9%E7%8E%A9/"}]}